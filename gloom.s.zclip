
	;OK, how to do object processing...
	;
	;process objects every 2nd vertical blank...set 'done' flag
	;
	;main program waits for 'done' flag, clrs it,  disables ints,
	;fetches display stuff, enables ints, draws display, waits for VB
	;and shows it!
	;
focshft	equ	6
grdshft	equ	8
darkshft	equ	7	;smaller=smaller range=faster!
maxz	equ	16<<darkshft
exshft	equ	4
linemod	equ	40*7
maxobjects	equ	64	;max objects in game

	jmp	entrypoint

	rsreset
	;
	;wall list...
	;
wl_next	rs.l	1
wl_lsx	rs.w	1	;leftmost screen X
wl_rsx	rs.w	1	;rightmost screen X
wl_nz	rs.w	1	;near Z!
wl_fz	rs.w	1	;far Z!
wl_lx	rs.w	1
wl_lz	rs.w	1
wl_rx	rs.w	1
wl_rz	rs.w	1
wl_a	rs.w	1
wl_b	rs.w	1
wl_c	rs.l	1
wl_t	rs.w	1
wl_sc	rs.w	1
	;
wl_size	rs.b	0

	rsreset
	;
	;a zone...
	;
zo_done	rs.w	1
zo_x1	rs.w	1
zo_z1	rs.w	1
zo_x2	rs.w	1
zo_z2	rs.w	1
zo_minx	rs.w	1
zo_maxx	rs.w	1
zo_minz	rs.w	1
zo_maxz	rs.w	1
zo_a	rs.w	1
zo_b	rs.w	1
	;
zo_t	rs.w	1
zo_t2	rs.w	1
zo_sc	rs.w	1
zo_ev	rs.w	1
zo_align2	rs.w	1
;
zo_size	rs.b	0	;32!

	rsreset
	;
	;a shape to draw!
	;
sh_next	rs.l	1
sh_x	rs.w	1
sh_y	rs.w	1
sh_z	rs.w	1
sh_shape	rs.l	1
	;
sh_size	rs.b	0

	rsreset
	;
	;an object in the game (player/alien etc...)
	;
ob_next	rs.l	1
ob_prev	rs.l	1
ob_x	rs.l	1
ob_y	rs.l	1
ob_z	rs.l	1
ob_rot	rs.l	1
	;
	;start of info load by prog.
ob_info	rs.b	0
	;
ob_rotspeed	rs.l	1
ob_movspeed	rs.l	1
ob_shape	rs.l	1
ob_logic	rs.l	1
ob_render	rs.l	1
ob_die	rs.l	1
ob_eyey	rs.w	1	;eye height
ob_firey	rs.w	1	;where bullets come from
ob_colltype	rs.w	1
ob_collwith	rs.w	1
ob_cntrl	rs.w	1
ob_rndfire	rs.w	1
ob_damage	rs.w	1
ob_hitpoints	rs.w	1
ob_rndturn	rs.w	1
ob_think	rs.w	1
	;
ob_xvec	rs.l	1
ob_zvec	rs.l	1
	;
ob_size	rs.b	0

	rsreset
	;
	;solid wall draw data
	;
vd_z	rs.w	1	;current Z
vd_pal	rs.w	1	;palette# (0...15)
vd_y	rs.w	1
vd_h	rs.w	1
vd_data	rs.l	1	;pointer to data to draw
vd_ystep	rs.l	1
	;
vd_size	rs.b	0

	rsreset
	;texture
	;
te_wshift	rs.w	1	;width shift
te_hshift	rs.w	1	;height shift
te_wand	rs.w	1
te_hand	rs.w	1
	;
te_size	rs.b	0

	rsreset
	;
	;window
	;
wi_slice	rs.l	1	;slice window appears in!
wi_nslice	rs.l	1	;next slice to disp.
wi_x	rs	1
wi_y	rs	1
wi_w	rs	1	;how many chixels across
wi_h	rs	1	;how many down
wi_pw	rs	1	;width of 1 chixel
wi_ph	rs	1	;hite of 1 chixel
	;
wi_bh	rs	1	;bitmap height
	;
wi_bmapmem	rs.l	1
wi_copmem	rs.l	1
wi_bmap	rs.l	1
wi_cop	rs.l	1
wi_cop1	rs.l	1
wi_cop2	rs.l	1
wi_copmod	rs.w	1
	;
wi_size	rs.b	0

key	macro
	btst	#\1&7,\1>>3(a0)
	endm

alloclist	macro	;alloclist listname,maxitems,itemsize
	;
	move.l	\2,d0
	move.l	\3,d1
	lea	\1(pc),a2
	jsr	k_alloclist
	bra.s	alskip\@
	;
\1	dc.l	0	;0
\1_last	dc.l	0	;4
	dc.l	0	;8
\1_free	dc.l	0	;12
alskip\@	;
	endm

k_alloclist	;a2=address of 'first' pointer
	;d0=max items, d1=item size
	;
	move.l	a2,8(a2)	;clear out used list
 	lea	4(a2),a0
	clr.l	(a0)
	move.l	a0,(a2)
	movem.l	d0-d1,-(a7)
	mulu	d1,d0
	move.l	#$10001,d1
	jsr	allocmem
	move.l	d0,a0
	lea	12(a2),a2
	movem.l	(a7)+,d0-d1
	subq	#1,d0
.loop	move.l	a0,(a2)
	move.l	a0,a2
	add	d1,a0
	dbf	d0,.loop
	rts

addnext	macro
	;
	;addnext 'listname'
	;add after a5
	;return eq if none available else a0
	;
	move.l	\1_free,d0
	beq.s	.anskip\@
	move.l	d0,a0
	move.l	(a0),\1_free
	move.l	(a5),a1
	move.l	a1,(a0)
	move.l	a0,4(a1)
	move.l	a0,(a5)
	move.l	a5,4(a0)
.anskip\@	;
	endm

addfirst	macro
	;
	;addfirst 'listname'
	;return eq if none available else a0
	;
	move.l	\1_free,d0
	beq.s	.afskip\@
	move.l	d0,a0
	move.l	(a0),\1_free
	move.l	\1,a1	;current first
	move.l	a1,(a0)
	move.l	a0,4(a1)
	move.l	a0,\1
	move.l	#\1,4(a0)
.afskip\@	;
	endm

addlast	macro
	;
	;addlast 'listname'
	;return eq in none available else a0
	;
	move.l	\1_free,d0
	beq.s	.alskip\@
	move.l	d0,a0
	move.l	(a0),\1_free
	;
	move.l	\1_last+4,a1	;current last
	move.l	a0,(a1)
	move.l	a1,4(a0)
	move.l	a0,\1_last+4
	move.l	#\1_last,(a0)
.alskip\@	;
	endm

killitem	macro
	;
	;killitem listname
	;a0=item to kill, return a0=previous item.
	;
	move.l	(a0),a1	;next of me!
	move.l	4(a0),4(a1)
	move.l	4(a0),a1	;prev of me
	move.l	(a0),(a1)
	move.l	\1_free,(a0)
	move.l	a0,\1_free
	move.l	a1,a0
	endm
	
clearlist	macro
	;
	;clearlist listname
	;
.clloop\@	move.l	\1,a0
	tst.l	(a0)
	beq	.cldone\@
	killitem	\1
	bra	.clloop\@
.cldone\@	;
	endm



bwait	macro
	;
.bwait\@	btst	#6,$dff002
	beq.s	.bwait2\@
	bra.s	.bwait\@
.bwait2\@	;
	endm

printlong	macro
	move.l	\1,-(a7)
	jsr	printlong_
	endm

check	macro
	list
check	set	*-\1
	nolist
	endm

push	macro
	movem.l	d2-d7/a2-a6,-(a7)
	endm

pull	macro
	movem.l	(a7)+,d2-d7/a2-a6
	endm

col	macro
	move	#0,$dff106
	move	\1,$dff180
	endm

entrypoint
cli	;
	move.l	a0,a2
	;
	lea	dosname,a1
	move.l	4.w,a6
	jsr	-408(a6)
	move.l	d0,dosbase
	;
	cmp.b	#'@',(a2)+
	bne.s	main
	move.l	a2,a0
	moveq	#1,d1
	bsr	loadfile
	move.l	d0,map_map
	bne.s	main
	rts
main	;
	lea	ciaaname,a1
	move.l	4.w,a6
	jsr	-498(a6)
	move.l	d0,a0
	move.l	$64(a0),a0
	lea	$136(a0),a0
	move.l	a0,rawtable
	;
	move	#$8400,$dff096
	;
	move.l	#32768,d0
	moveq	#1,d1
	jsr	allocmem
	move.l	d0,memory
	;
	lea	palettes,a2
	moveq	#15,d2
.palloop	move.l	#512,d0
	moveq	#1,d1
	jsr	allocmem
	move.l	d0,(a2)+
	dbf	d2,.palloop
	;
	move.l	#24*256,d0
	moveq	#1,d1
	jsr	allocmem
	move.l	d0,rgbs
	;
	move.l	#320*vd_size,d0
	moveq	#1,d1
	jsr	allocmem
	move.l	d0,vertdraws
	;
	jsr	initmap
	jsr	initdisplay
	jsr	ownblitter
	jsr	initvbint
	jsr	forbid
	;
	move.l	map_poly(pc),a0
.loop	cmp.l	map_ppnt(pc),a0
	bcc.s	.done
	clr	(a0)
	lea	32(a0),a0
	bra.s	.loop
.done	clr	frame
	;
	alloclist	objects,#maxobjects,#ob_size
	;
	jsr	dispoff
	;
	jsr	makecoloffs
	;
	lea	window1,a0
	bsr	makewindow
	lea	window2,a0
	bsr	makewindow
	;
	lea	window1,a0
	bsr	showwindow
	lea	window1,a0
	bsr	dbwindow
	lea	window2,a0
	bsr	showwindow
	lea	window2,a0
	bsr	dbwindow
	;
	move	blob+6,d0
	lsr	#1,d0
	move	d0,blob+2
	;
	move	blob2+6,d0
	lsr	#1,d0
	move	d0,blob2+2
	;
	move	#$1f3a,d0
	bsr	seedrnd
	;
	clr.l	player1
	clr.l	player2
	not.l	player2
	moveq	#1,d0
	bsr	execevent
	;
	bsr	dispon
	clr	doneflag
	;
mainloop	tst	doneflag
	beq.s	mainloop	;wait for updated!
	clr	doneflag
	;
	move.l	memory(pc),memat
	;
	move.l	player1(pc),a0
	bsr	calcscene
	lea	window1,a0
	bsr	drawscene
	;
	;move.l	player2(pc),a0
	;bsr	calcscene
	;lea	window2,a0
	;bsr	drawscene
	;
	;bsr	vwait	;!*!
	;
	lea	window1,a0
	bsr	showwindowq
	lea	window2,a0
	bsr	showwindowq
	;
	move.l	rawtable(pc),a0
	key	$45
	beq	mainloop
	;
	bsr	permit
	bsr	finitvbint
	bsr	disownblitter
	bsr	finitdisplay
	;
	bsr	freememlist
	rts

; ************* FAST SUBS ********************

fastsubs

execevent	;d0=event number to execute...1,2...
	;
	move.l	map_map(pc),a6
	add.l	16(a6,d0*4),a6
	;
exec_loop	move	(a6)+,d0
	beq.s	.rts
	subq	#1,d0
	beq	exec_addobj	;1
	subq	#1,d0
	beq	exec_loop	;2
	subq	#1,d0
	beq	exec_loop	;3
	subq	#1,d0
	beq	exec_loop	;4
	subq	#1,d0
	beq	exec_loop	;5
	;
.rts	rts

exec_addobj	clr.l	dummy
	move	(a6)+,d0	;monster type
	lea	objinfo,a2
	mulu	#objinfof-objinfo,d0
	add.l	d0,a2
	move.l	(a2)+,a3
	tst.l	(a3)
	beq.s	.ok
.no	addq	#8,a6
	bra	exec_loop
.ok	addlast	objects
	beq.s	.no
	move.l	a0,a5
	;
	move.l	a5,(a3)
	move	(a6)+,ob_x(a5)
	move	(a6)+,ob_y(a5)
	move	(a6)+,ob_z(a5)
	move	(a6)+,ob_rot(a5)
	sub	#64,ob_rot(a5)
	and	#255,ob_rot(a5)
	lea	ob_info(a5),a3
	move	#(objinfof-objinfo-4)>>1-1,d0
.loop	move	(a2)+,(a3)+
	dbf	d0,.loop
	;
	bsr	calcvecs
	movem.l	d4-d5,ob_xvec(a5)
	bra	exec_loop

seedrnd	;seed number in d0.w
	;
	moveq	#54,d1
	lea	rndtable(pc),a0
.loop	move	d0,(a0)+
	mulu	#$1efd,d0
	add	#$dff,d0
	dbf	d1,.loop
	move.l	a0,(a0)
	move.l	#rndtable+48,j_index
	rts

rndw	;return rnd number 0...65535 if d0.w
	;
	movem.l	a0/a1,-(a7)
	lea	rndtable(pc),a1
	move.l	j_index(pc),a0
	move	-(a0),d0
	cmp.l	a0,a1
	bne.s	.skip
	lea	rndtable+110(pc),a0
.skip	move.l	a0,j_index
	move.l	k_index(pc),a0
	add	-(a0),d0
	move	d0,(a0)
	cmp.l	a0,a1
	bne.s	.skip2
	lea	rndtable+110(pc),a0
.skip2	move.l	a0,k_index
	movem.l	(a7)+,a0/a1
	rts

rndtable	ds.w	55
k_index	dc.l	0
j_index	dc.l	0

rndl	bsr	rndw
	move	d0,d1
	bsr	rndw
	swap	d0
	move	d1,d0
	rts

rndn	move	d0,d1
	bsr	rndw
	mulu	d1,d0
	swap	d0
	rts

calcangle2	;angle of camera to object in a5
	;
	move	camx(pc),d0
	sub	ob_x(a5),d0
	move	camz(pc),d1
	sub	ob_z(a5),d1
	bra.s	calcangle_

calcangle	;angle of object a5 to object a0...
	;
	move	ob_x(a0),d0
	sub	ob_x(a5),d0
	move	ob_z(a0),d1
	sub	ob_z(a5),d1
	;
calcangle_	;d0.w=x d1.w=y (dest-src)!
	;
	moveq	#0,d2
	tst	d1
	bpl.s	.hpos
	moveq	#16,d2
	neg	d1
.hpos	tst	d0
	bpl.s	.wpos
	eor	#8,d2
	neg	d0
.wpos	cmp	d1,d0
	bmi.s	.notsteep
	bne.s	.neq
	move	#$2000,d1
	bra.s	.flow
.neq	eor	#4,d2
	exg	d1,d0
.notsteep	tst	d1
	bne.s	.noflow
	moveq	#0,d1
	bra.s	.flow
.noflow	ext.l	d0
	swap	d0
	divu	d1,d0
	lsr	#6,d0
	and	#1022,d0
	move	.arc(pc,d0),d1
.flow	move.l	.oct(pc,d2),d0
	eor	d0,d1
	swap	d0
	add	d1,d0
	lsr	#8,d0
	rts
	;
.oct	dc	0,0,$4000,-1,0,-1,$c000,0
	dc	$8000,-1,$4000,0,$8000,0,$c000,-1
.arc	incbin	arc.bin

calcscene	;a0=player object
	;
	move	#$4000,$dff09a
	move.l	a0,-(a7)
	clr.l	shapelist
	bsr	calccamera
	bsr	makewalls
	;
	lea	objects(pc),a5
.loop	move.l	(a5),a5
	tst.l	(a5)
	beq.s	.done
	cmp.l	(a7),a5
	beq.s	.loop
	move.l	ob_render(a5),a0
	jsr	(a0)
	bra.s	.loop
.done	;
	move	#$c000,$dff09a
	addq	#4,a7
	rts

drawscene	;a0=window
	;
	bsr	dbwindow
	bsr	castwalls
	bsr	renderwindow
	bsr	drawshapes
	rts

vbhandler	subq	#1,(a1)+
	addq	#1,(a1)
	btst	#0,1(a1)
	beq	rts
	;
	;OK, movement/animation stuff!
	;
	movem.l	d0-d7/a0-a6,-(a7)
	;
	bsr	readjoys
	;
	;do object logic
	;
	move.l	a7,obj_stack
	lea	objects(pc),a5
	;
obj_loop	move.l	(a5),a5
	tst.l	(a5)
	beq	exit_vb
	;
	move.l	ob_logic(a5),a0
	jsr	(a0)
	;
	;check collision!
	;
	move	ob_collwith(a5),d0
	beq.s	obj_loop
	;
	move.l	ob_shape(a5),a0
	move	4(a0),d1
	lsr	#1,d1	;radius!
	move	ob_x(a5),d6
	move	ob_z(a5),d7
	;
	lea	objects(pc),a0
	;
.loop2	move.l	(a0),a0
	cmp.l	a5,a0
	beq.s	obj_loop
	;
	move	ob_colltype(a0),d2
	and	d0,d2
	beq.s	.loop2
	;
	move.l	ob_shape(a0),a1
	move	4(a1),d2
	lsr	#1,d2	;radius!
	add	d1,d2	;r sum
	;
	move	ob_x(a0),d3
	sub	d6,d3
	bpl.s	.xpl
	neg	d3
.xpl	cmp	d2,d3
	bcc.s	.loop2
	;
	move	ob_z(a0),d4
	sub	d7,d4
	bpl.s	.ypl
	neg	d4
.ypl	cmp	d2,d4
	bcc.s	.loop2
	;
	mulu	d2,d2
	mulu	d3,d3
	mulu	d4,d4
	add.l	d4,d3
	cmp.l	d2,d3
	bcc.s	.loop2
	;
	col	#$fff
	;
	subq	#1,ob_hitpoints(a0)
	bgt.s	hit_skip
	;
	move.l	#killobject3,killjsr
	move.l	a5,obj_a5
	;
	move.l	a0,a5
	move.l	ob_die(a5),a0
	jsr	(a0)
hit_ret	;
	move.l	obj_a5(pc),a5
	move.l	#killobject2,killjsr
	;
hit_skip	subq	#1,ob_hitpoints(a5)
	bgt.s	hit_skip2
	move.l	ob_die(a5),a0
	jsr	(a0)
hit_skip2	;
	bra	obj_loop
	;	
exit_vb	st	doneflag
	movem.l	(a7)+,d0-d7/a0-a6
	moveq	#0,d0
	;
rts	rts

obj_a5	dc.l	0
obj_stack	dc.l	0
killjsr	dc.l	killobject2

killobject	;
	move.l	killjsr(pc),a0
	jmp	(a0)

killobject2	move.l	a5,a0
	killitem	objects
	move.l	a0,a5
	move.l	obj_stack(pc),a7
	bra	obj_loop

killobject3	move.l	a5,a0
	killitem	objects
	move.l	obj_stack(pc),a7
	bra	hit_ret

monsterlogic	;
	;monster cruising around minding his own business...
	;
	bsr	rndw
	cmp	ob_rndturn(a5),d0
	bcc.s	.noturn
	;
.turn	;turn 45 degrees randomly left or right!
	;
	moveq	#32,d1
	bsr	rndw
	tst	d0
	bpl.s	.pl
	neg	d1
.pl	add	d1,ob_rot(a5)
	movem.l	d1,-(a7)
	bsr	calcvecs
	move.l	ob_x(a5),d6
	move.l	ob_z(a5),d7
	bsr	mover2
	movem.l	(a7)+,d1
	bne.s	.pl
	movem.l	d4-d5,ob_xvec(a5)
	move.l	d6,ob_x(a5)
	move.l	d7,ob_z(a5)
	rts
	;
.noturn	movem.l	ob_xvec(a5),d4-d5
	move.l	ob_x(a5),d6
	move.l	ob_z(a5),d7
	bsr	mover2
	bne.s	.turn
	move.l	d6,ob_x(a5)
	move.l	d7,ob_z(a5)
	rts

calcvecs	move	ob_rot(a5),d0
	and	#255,d0
	move.l	camrots(pc),a0
	lea	0(a0,d0*8),a0
	move	ob_movspeed(a5),d4
	move	d4,d5
	muls	2(a0),d4
	add.l	d4,d4
	muls	6(a0),d5
	add.l	d5,d5
	rts

playerdeath	addq	#4,ob_rot(a5)
	addq	#4,ob_eyey(a5)
	blt.s	.rts
	move.l	#rts,ob_logic(a5)
.rts	rts

playerdie	move.l	#playerdeath,ob_logic(a5)
	clr.l	ob_colltype(a5)
	rts

playerlogic	lea	joyx0(pc),a0
	move	ob_cntrl(a5),d0
	beq.s	.skip
	lea	joyx1(pc),a0
.skip	;
	move	(a0),d0	;joyx - rotate
	muls	ob_rotspeed(a5),d0
	add	ob_rot(a5),d0
	and	#255,d0
	move	d0,ob_rot(a5)
	;
	;move...
	;
	move	2(a0),d4
	neg	d4
	muls	ob_movspeed(a5),d4	;speed
	move.l	camrots(pc),a1
	lea	0(a1,d0*8),a1
	move	d4,d5		;real speed
	muls	2(a1),d4
	add.l	d4,d4
	muls	6(a1),d5
	add.l	d5,d5
	move.l	ob_x(a5),d6
	move.l	ob_z(a5),d7
	;
	bsr	mover
	;
	move.l	d6,ob_x(a5)
	move.l	d7,ob_z(a5)
	;
	bra	checkfire
	;
	bsr	checknew3	;in a trigger zone?
	bne.s	checkfire
	;
	move.l	new_grid(pc),a0
	moveq	#-16,d0
.loop	tst	(a0)
	bpl.s	.here
	add.l	d0,a0
	bra.s	.loop
	;
.here	move	2(a0),d0	;first
	move.l	map_ppnt(pc),a1
	move	0(a1,d0*2),d0	;poly#
	move.l	map_poly(pc),a0
	lsl	#5,d0
	move	zo_ev(a0,d0),d0
	beq.s	checkfire
	;
	;OK, gotta clear all 'event' zones with same type!
	;
	moveq	#32,d1
	moveq	#0,d2
.loop2	cmp	zo_ev(a0),d0
	bne.s	.skip2
	move	d2,zo_ev(a0)
.skip2	add.l	d1,a0
	cmp.l	a1,a0
	bcs.s	.loop2
	;
	move.l	a5,-(a7)
	bsr	execevent
	move.l	(a7)+,a5
	;
checkfire	move	joyf0(pc),d0
	tst	ob_cntrl(a5)
	beq.s	.skip
	move	joyf1(pc),d0
.skip	tst	d0
	beq	.rts
	;
	addfirst	objects
	beq	.rts
	;
	move	ob_x(a5),ob_x(a0)
	move	ob_y(a5),d0
	add	ob_firey(a5),d0
	move	d0,ob_y(a0)
	move	ob_z(a5),ob_z(a0)
	move.l	#firelogic,ob_logic(a0)
	move.l	#drawshape,ob_render(a0)
	move.l	#killobject,ob_die(a0)
	move.l	#blob,ob_shape(a0)
	move	ob_collwith(a5),d0
	eor	#3,d0
	move	d0,ob_colltype(a0)
	cmp	#2,d0
	beq.s	.sk
	move.l	#blob2,ob_shape(a0)
.sk	move	#0,ob_collwith(a0)
	move	#1,ob_hitpoints(a0)
	;
	move	ob_rot(a5),d0
	move.l	camrots(pc),a1
	lea	0(a1,d0*8),a1
	;
	move	2(a1),d0
	ext.l	d0
	lsl.l	#6,d0
	;
	move	6(a1),d1
	ext.l	d1
	lsl.l	#6,d1
	;
	movem.l	d0-d1,ob_xvec(a0)
	;
.rts	rts

firelogic	;
	movem.l	ob_xvec(a5),d4-d5
	move.l	ob_x(a5),d6
	move.l	ob_z(a5),d7
	bsr	mover
	bne	killobject
	move.l	d6,ob_x(a5)
	move.l	d7,ob_z(a5)
	rts

drawshape_8	;
	;shape has 8 rotations!
	;
	bsr	calcangle2
	add	#16,d0
	add	ob_rot(a5),d0
	lsr	#5,d0
	and	#7,d0
	lea	shrots,a0
	move.l	0(a0,d0*4),a0
	move	ob_x(a5),d0
	move	ob_y(a5),d1
	move	ob_z(a5),d2
	bra.s	drawshape_

drawshape	;
	move	ob_x(a5),d0
	move	ob_y(a5),d1
	move	ob_z(a5),d2
	move.l	ob_shape(a5),a0
drawshape_	;
	;A0=shape
	;D0=X
	;D1=Y
	;D2=Z
	;
	;rotate Z around camera!
	;
	sub	camx(pc),d0
	sub	camy(pc),d1
	sub	camz(pc),d2
	;
	move	d0,d3
	move	d2,d5
	muls	cm3(pc),d3
	muls	cm4(pc),d2
	add.l	d3,d2
	add.l	d2,d2
	swap	d2
	;
	cmp	#maxz,d2
	bge	.rts
	cmp	#1,d2
	ble	.rts
	;
	muls	cm1(pc),d0
	muls	cm2(pc),d5
	add.l	d5,d0
	add.l	d0,d0
	swap	d0
	;
	sub	(a0)+,d0	;handles!
	sub	(a0)+,d1
	;
	move.l	memat(pc),a1
	add.l	#sh_size,memat
	movem	d0-d2,sh_x(a1)
	move.l	a0,sh_shape(a1)
	;
	lea	shapelist(pc),a2
.loop	move.l	(a2),d0
	beq.s	.end
	move.l	a2,a3
	move.l	d0,a2
	cmp	sh_z(a2),d2	;nearer...further in list
	blt.s	.loop
	move.l	a2,(a1)
	move.l	a1,(a3)
	rts
.end	move.l	d0,(a1)
	move.l	a1,(a2)
.rts	rts

drawshapes	lea	shapelist(pc),a6
	;
.drawloop	move.l	(a6),d0
	beq	.rts
	move.l	d0,a6
	movem	sh_x(a6),d0-d2
	move.l	sh_shape(a6),a0
	;
	;d0=rotated X, d1=Y, d2=Z
	;
	;work out real width/height!
	;
	lsl.l	#focshft,d0
	divs	d2,d0	;Screen X
	cmp	maxx(pc),d0
	bge	.drawloop	;X too big!
	;
	lsl.l	#focshft,d1
	divs	d2,d1	;Screen Y
	cmp	maxy(pc),d1
	bge	.drawloop
	;
	movem	(a0),d3-d4
	;
	move.l	d3,d5
	lsl.l	#focshft,d3
	divs	d2,d3	;screen width
	ext.l	d3
	ble	.drawloop
	;
	move.l	d4,d6
	lsl.l	#focshft,d4
	divs	d2,d4	;hite
	ext.l	d4
	ble	.drawloop
	;
	swap	d5
	divu.l	d3,d5	;x step.q
	;
	add	midx(pc),d0
	bpl.s	.xcskip
	add	d0,d3	;reduce width
	ble	.drawloop
	moveq	#0,d7
	neg	d0
	ext.l	d0
	mulu.l	d5,d0	;start column in shape
	cmp	width(pc),d3
	ble.s	.xcdone
	move	width(pc),d3
	bra.s	.xcdone
	;
.xcskip	move	d0,d7	;sc X
	add	d3,d0
	sub	width(pc),d0
	ble.s	.xcdone2
	sub	d0,d3
	ble	.drawloop
.xcdone2	move.l	d5,d0
	lsr.l	#1,d0
.xcdone	;
	swap	d6
	divu.l	d4,d6	;y step
	;
	move.l	cop(pc),a1
	;
	add	midy(pc),d1
	bpl.s	.ycskip
	add	d1,d4	;hite
	ble	.drawloop
	neg	d1
	ext.l	d1
	mulu.l	d6,d1
	cmp	hite(pc),d4
	ble.s	.ycdone
	move	hite(pc),d4
	bra.s	.ycdone
	;
.ycskip	move	d1,-(a7)
	mulu	copmod(pc),d1
	add.l	d1,a1
	move	(a7)+,d1
	add	d4,d1
	sub	hite(pc),d1
	ble.s	.ycdone2
	sub	d1,d4
	ble	.drawloop
.ycdone2	move.l	d6,d1
	lsr.l	#1,d1
.ycdone	;
	;draw bit...
	;
	;a0=src, a1=dest, a2=palette
	;
	;d0.q=src x
	;d1.q=src y
	;d2.w = Z!
	;d3.w=width
	;d4.w=height
	;d5.q=x step
	;d6.q=y step
	;d7.w=start screen column
	;a0.l=src
	;a1.l=dest
	;a2.l=palette
	;
	move.l	a6,-(a7)
	;
	lea	coloffs,a5
	lea	0(a5,d7*4),a5
	;
	move.l	vertdraws(pc),a6
	mulu	#vd_size,d7
	lea	0(a6,d7),a6
	;
	lea	palettes,a2
	move	d2,d7
	lsr	#darkshft,d7
	move.l	0(a2,d7*4),a2
	;
	subq	#1,d3
	subq	#1,d4
	swap	d0
	swap	d1
	swap	d5
	swap	d6
	addq	#2,a0
	;
.hloop	move.l	a1,a4
	add.l	(a5)+,a4
	cmp	vd_z(a6),d2
	bge	.zbad
	;
	movem.l	d0-d1/d4-d5,-(a7)
	;
	mulu	(a0),d0
	lea	2(a0,d0),a3	;src
	;
	move	copmod(pc),d7
	ext.l	d7
	moveq	#0,d5
	moveq	#0,d0
	;
.vloop	move.b	0(a3,d1),d5
	beq.s	.skip
	move	0(a2,d5*2),(a4)
.skip	add.l	d6,d1	;next src Y
	addx.l	d0,d1
	add.l	d7,a4
	dbf	d4,.vloop
	;
	movem.l	(a7)+,d0-d1/d4-d5
	;
.zbad	add.l	d5,d0
	moveq	#0,d7
	addx.l	d7,d0	;next src X
	lea	vd_size(a6),a6
	;
	dbf	d3,.hloop
	;
	move.l	(a7)+,a6
	bra	.drawloop
	;
.rts	rts

printcampos	move	camx(pc),d6
	lsr	#grdshft,d6
	ext.l	d6
	;
	move	camz(pc),d7
	lsr	#grdshft,d7
	ext.l	d7
	;
	move	d7,d5
	lsl	#5,d5
	add	d6,d5
	move.l	map_grid(pc),a0
	move	0(a0,d5*4),d5
	and.l	#$ffff,d5
	;
	printlong	d6
	printlong	d7
	printlong	d5
	;
	rts

mover	;
	;d4=x speed
	;d5=z speed
	;d6=x
	;d7=z
	;
	;return d0, ne if a wall was hit!
	;check only walls zone (player)
	;
	neg.l	d4
	moveq	#0,d3
	add.l	d4,d6
	add.l	d4,d6
	add.l	d4,d6
	bsr	checknew
	beq.s	.xok
	moveq	#-1,d3
	sub.l	d4,d6
.xok	sub.l	d4,d6
	sub.l	d4,d6
	;
	add.l	d5,d7
	add.l	d5,d7
	add.l	d5,d7
	bsr	checknew
	beq.s	.zok
	moveq	#-1,d3
	sub.l	d5,d7
.zok	sub.l	d5,d7
	sub.l	d5,d7
	tst	d3
	rts

mover2	;
	;d4=x speed
	;d5=z speed
	;d6=x
	;d7=z
	;
	;return d0, ne if a wall was hit!
	;check walls AND monster zones
	;
	neg.l	d4
	moveq	#0,d3
	add.l	d4,d6
	add.l	d4,d6
	add.l	d4,d6
	bsr	checknew
	bne.s	.xbad
	bsr	checknew2
	beq.s	.xok
.xbad	moveq	#-1,d3
	sub.l	d4,d6
.xok	sub.l	d4,d6
	sub.l	d4,d6
	;
	add.l	d5,d7
	add.l	d5,d7
	add.l	d5,d7
	bsr	checknew
	bne.s	.zbad
	bsr	checknew2
	beq.s	.zok
.zbad	moveq	#-1,d3
	sub.l	d5,d7
.zok	sub.l	d5,d7
	sub.l	d5,d7
	tst	d3
	rts

checknew3	;check trigger event zone
	move.l	map_grid(pc),a0
	addq	#8,a0
	bra.s	checknew_
new_grid	dc.l	0

checknew2	;check monster zone
	move.l	map_grid(pc),a0
	addq	#4,a0
	bra.s	checknew_

checknew	;check wall zone
	move.l	map_grid(pc),a0
	;
checknew_	movem.l	d3-d5,-(a7)
	swap	d6
	swap	d7
	;
	addq	#1,frame
	move	frame(pc),d5
	move	d6,d0
	move	d7,d1
	lsr	#grdshft,d0	;x count
	lsr	#grdshft,d1
	lsl	#5,d1
	add	d0,d1
	lsl	#4,d1
	lea	0(a0,d1),a0
	move.l	a0,new_grid
	moveq	#1,d1
	move.l	map_ppnt(pc),a1
	move.l	map_poly(pc),a2
	;
	;d0=counter to left of map!
	;d1=in/out counter
	;
.loop	move	(a0)+,d2	;how many in this grid!
	bmi	.next
	;
	move	(a0),d3
	lea	0(a1,d3*2),a3
	;
.loop2	move	(a3)+,d3
	lsl	#5,d3
	lea	0(a2,d3),a4
	;
	cmp	zo_done(a4),d5
	beq	.next2
	move	d5,zo_done(a4)
	;
	cmp	zo_minz(a4),d7
	blt	.next2
	cmp	zo_maxz(a4),d7
	bge	.next2
	;
	;OK, we are in the z area!
	;
	cmp	zo_minx(a4),d6
	blt	.next2	;too far left!
	cmp	zo_maxx(a4),d6
	bgt	.inc
	;
	;have to do test!
	;
	movem	zo_x1(a4),d3-d4	;x1,z1
	sub	d6,d3
	muls	zo_a(a4),d3
	sub	d7,d4
	muls	zo_b(a4),d4
	add.l	d4,d3
	bpl.s	.next2
	;
.inc	addq	#1,d1
	;
.next2	dbf	d2,.loop2
	;
.next	lea	-18(a0),a0
	dbf	d0,.loop
	;
	swap	d6
	swap	d7
	and	#1,d1
	movem.l	(a7)+,d3-d5
	rts

calccamera	;a0=player object
	;	
	move	ob_x(a0),camx
	move	ob_y(a0),d0
	add	ob_eyey(a0),d0
	move	d0,camy
	move	ob_z(a0),camz
	move	ob_rot(a0),d0
	and	#255,d0
	move	d0,camr
	move.l	camrots(pc),a1
	lea	0(a1,d0*8),a1
	move.l	(a1)+,cm1
	move.l	(a1),cm3
	;
	rts

readjoys	;set up joyx0,joyy0,joyx1,joyy1
	;
	move.l	rawtable(pc),a0
	moveq	#0,d0
	key	$4f
	beq.s	.nleft
	moveq	#-1,d0
.nleft	key	$4e
	beq.s	.nrite
	moveq	#1,d0
.nrite	move	d0,joyx0
	moveq	#0,d0
	key	$4c
	beq.s	.nup
	moveq	#-1,d0
.nup	key	$4d
	beq.s	.ndown
	moveq	#1,d0
.ndown	move	d0,joyy0
	key	$64
	sne	d0
	ext	d0
	move	d0,d1
	beq.s	.nofire
	tst	joyb0
	beq.s	.nofire
	moveq	#0,d1
.nofire	move	d1,joyf0
	move	d0,joyb0
	;
	elseif
	move.b	$bfe001,d3
	move	$dff00a,d2	;joy0
	bsr	readjoy
	move	d0,joyx0
	move	d1,joyy0
	bsr	makerot
	move	d0,joyr0
	btst	#6,$bfe001                                      
	seq	d0
	ext	d0
	move	d0,d1
	beq.s	.nofire
	tst	joyb0
	beq.s	.nofire
	moveq	#0,d1
.nofire	move	d1,joyf0
	move	d1,help
	move	d0,joyb0
	elseif
	;
	move	$dff00c,d2
	bsr	readjoy
	move	d0,joyx1
	move	d1,joyy1
	bsr	makerot
	move	d0,joyr1
	btst	#7,$bfe001
	seq	d0
	ext	d0
	move	d0,d1
	beq.s	.nofire2
	tst	joyb1
	beq.s	.nofire2
	moveq	#0,d1
.nofire2	move	d1,joyf1
	move	d0,joyb1
	;
	rts

makerot	;convert d0,d1 into a rotation type setting...
	;
	;0=up, 1=up/rite, 2=rite etc...
	;
	;<0=no dir
	;
	addq	#1,d0
	lsl	#2,d0
	addq	#1,d1
	or	d1,d0
	add	d0,d0
	move	rots(pc,d0),d0
	rts

rots	;x=-1
	dc	7,6,5,-1
	;x=0
	dc	0,-1,4,-1
	;x=1
	dc	1,2,3,-1

readjoy	bsr	joydir
	move	d1,d0
	move	d2,d1
	add	d1,d1
	eor	d1,d2
	;
joydir	btst	#9,d2
	bne.s	.neg
	btst	#1,d2
	bne.s	.pos
	moveq	#0,d1
	rts
.neg	moveq	#-1,d1
	rts
.pos	moveq	#1,d1
	rts

gridoffs	incbin	gridoffs.bin
gridoffsf

makewalls	;
	;New approach!
	;
	;use poly's line eq to test perpendicular distance to wall
	;produce nearest -> furthest wall list.
	;
	;optimizations...
	;check if both z's are negative after rotation
	;check if projected left/rite ends are on screen
	;
	addq	#1,frame
	;
	clr.l	inlist
	move.l	#inlist,inlistf
	clr.l	outlist
	move.l	#outlist,outlistf
	;
	move.l	map_poly(pc),a4
	move.l	map_ppnt(pc),a3
	move.l	map_grid(pc),a2
	movem	camx(pc),d6-d7	;x,z
	lsr	#grdshft,d6
	lsr	#grdshft,d7
	lea	gridoffs(pc),a6
	moveq	#(gridoffsf-gridoffs)>>2-1,d5
	;
.loop	movem	(a6)+,d0-d1
	add	d6,d0
	cmp	#32,d0
	bcc	.skip
	add	d7,d1
	cmp	#32,d1
	bcc	.skip
	;
	;d0,d1=x/z of map to check!
	;
	lsl	#5,d1	;Y*32...
	add	d1,d0	;+X
	lsl	#4,d0
	lea	0(a2,d0),a0	;mapgrid
	move	(a0)+,d4	;how many polys here
	bmi	.skip
	move	(a0),d0	;poly data offset
	lea	0(a3,d0*2),a0
	;
.loop2	move	(a0)+,d0	;poly#
	lsl	#5,d0
	lea	0(a4,d0),a1	;actual poly
	move	frame(pc),d0
	cmp	zo_done(a1),d0
	beq	.skip3
	move	d0,zo_done(a1)
	;
	;OK, setup:
	;
	;d0=lx,d1=lz,d2=rx,d3=rz
	;d4=t,d5=sc,d6=dist
	;
	;back face/dist check...
	;
	movem	d4-d7,-(a7)
	;
	movem	zo_x1(a1),d0-d3	;x1,z1,x2,z2
	movem	camx(pc),d6-d7
	;
	sub	d6,d0
	sub	d7,d1
	sub	d6,d2
	sub	d7,d3
	;
	move	d0,d4
	move	d1,d5
	muls	cm1(pc),d0
	muls	cm2(pc),d5
	add.l	d5,d0
	add.l	d0,d0
	swap	d0	;LX
	muls	cm3(pc),d4
	muls	cm4(pc),d1
	add.l	d4,d1
	add.l	d1,d1
	swap	d1	;LZ
	;
	move	d2,d4
	move	d3,d5
	muls	cm1(pc),d2
	muls	cm2(pc),d5
	add.l	d5,d2
	add.l	d2,d2
	swap	d2	;RX
	muls	cm3(pc),d4
	muls	cm4(pc),d3
	add.l	d4,d3
	add.l	d3,d3
	swap	d3	;RZ
	;
	tst	d3
	bgt.s	.zok
	tst	d1
	ble	.skip2
	;
.zok	;do backface check...generate a,b,c...
	;
	move	d1,d4
	sub	d3,d4	;a
	move	d2,d5
	sub	d0,d5	;b
	;
	move	d0,d6
	muls	d4,d6
	move	d1,d7
	muls	d5,d7
	add.l	d7,d6
	bpl.s	.front
	;
	;backface showing!...
	bra	.skip2
.front	;
	move.l	memat(pc),a5
	movem	d0-d5,wl_lx(a5)
	move.l	d6,wl_c(a5)
	;
	;gotta create screen coords...z clip
	;
	;elseif
	;
	tst	d1
	bgt.s	.z1ok
	;
	;lz bad, rz must be OK...
	;
	move	#-32768,d5
	bra	.z1sk
	;
	move	d3,d5
	sub	d1,d5
	move	d1,d6
	neg	d6
	swap	d6
	clr	d6
	divu	d5,d6	;frac
	move	d2,d5
	sub	d0,d5
	mulu	d6,d5
	swap	d5
	add	d0,d5
	bra.s	.z1sk
	;
.z1ok	move	d0,d5
	ext.l	d5
	lsl.l	#focshft,d5
	divs	d1,d5
	;
.z1sk	move	d5,wl_lsx(a5)
	;
	tst	d3
	bgt.s	.z2ok
	;
	;rz bad, lz must be OK...
	;
	move	#32767,d2
	bra	.z2sk
	;
	move	d1,d5
	sub	d3,d5
	move	d1,d6
	swap	d6
	clr	d6
	divu	d5,d6
	sub	d0,d2
	mulu	d6,d2
	swap	d2
	add	d0,d2
	bra.s	.z2sk
	;
.z2ok	ext.l	d2
	lsl.l	#focshft,d2
	divs	d3,d2
	;
.z2sk	move	d2,wl_rsx(a5)
	;
	movem	wl_lsx(a5),d0/d2
	cmp	d0,d2
	bge.s	.sxok
	move	d2,wl_lsx(a5)
	move	d0,wl_rsx(a5)
.sxok	;
	;elseif
	;
	cmp	d1,d3
	bge.s	.zskp
	exg	d1,d3
.zskp	movem	d1/d3,wl_nz(a5)	;near/far Z
	move	zo_t(a1),wl_t(a5)
	move	zo_sc(a1),wl_sc(a5)
	;
	;add to end of inlist...
	;
	clr.l	(a5)
	move.l	inlistf(pc),a1
	move.l	a5,(a1)
	move.l	a5,inlistf
	add.l	#wl_size,memat
	;
.skip2	movem	(a7)+,d4-d7
	;
.skip3	dbf	d4,.loop2	;finish sq
	;
.skip	dbf	d5,.loop	;gridoffs

makeoutlist	;create outlist from inlist
	;
.loop0	lea	inlist(pc),a0
	;
.loop	move.l	(a0),d0
	beq	.done
	move.l	a0,a2	;save previous!
	move.l	d0,a0
	;
	;OK, see if any are in front of a0...
	;
	lea	inlist(pc),a1
	;
.loop2	move.l	(a1),d0
	beq	.none
	move.l	a1,a3
	move.l	d0,a1
	;
	cmp.l	a0,a1
	beq.s	.loop2	;don't compare with self!
	;
	;see if a1 is in front of a0
	;
	move	wl_nz(a1),d0
	cmp	wl_fz(a0),d0
	bge	.loop2	;behind!
	;
	move	wl_fz(a1),d0
	cmp	wl_nz(a0),d0
	ble	.swap
	;
	;now, compare screen x coords.....
	;
	move	wl_rsx(a0),d0
	cmp	wl_lsx(a1),d0
	blt	.loop2
	;
	move	wl_lsx(a0),d0
	cmp	wl_rsx(a1),d0
	bgt	.loop2
	;
	;look at a0 points against a1 line
	;
	;If Sgn((x3-x1)*a2+(y3-y1)*b2)<>Sgn(c2)
	;  If Sgn((x3-x2)*a2+(y3-y2)*b2)<>Sgn(c2)
	;    tr=-1:Return
	;  EndIf
	;EndIf
	;
	movem	wl_a(a1),d5-d6
	move.l	wl_c(a1),d7
	;
	move	wl_lx(a1),d0
	sub	wl_lx(a0),d0
	muls	d5,d0
	move	wl_lz(a1),d1
	sub	wl_lz(a0),d1
	muls	d6,d1
	add.l	d1,d0
	eor.l	d7,d0
	;
	move	wl_lx(a1),d1
	sub	wl_rx(a0),d1
	muls	d5,d1
	move	wl_lz(a1),d2
	sub	wl_rz(a0),d2
	muls	d6,d2
	add.l	d2,d1
	eor.l	d7,d1
	;
	;OK, screen X's overlap...
	;if both a0 in front, no swap
	;
	move.l	d0,d4
	or.l	d1,d4
	bpl	.loop2
	;
	;if both a0 behind, swap
	;
	move.l	d0,d4
	and.l	d1,d4
	bmi	.swap
	;
	;look at a1 points against a0 line
	;
	;If Sgn((x1-x3)*a1+(y1-y3)*b1)=Sgn(c1)
	;  If Sgn((x1-x4)*a1+(y1-y4)*b1)=Sgn(c1)
	;    tr=-1:Return
	;  EndIf
	;EndIf
	;
	movem	wl_a(a0),d5-d6
	move.l	wl_c(a0),d7
	;
	move	wl_lx(a0),d2
	sub	wl_lx(a1),d2
	muls	d5,d2
	move	wl_lz(a0),d3
	sub	wl_lz(a1),d3
	muls	d6,d3
	add.l	d3,d2
	eor.l	d7,d2
	;
	move	wl_lx(a0),d3
	sub	wl_rx(a1),d3
	muls	d5,d3
	move	wl_lz(a0),d4
	sub	wl_rz(a1),d4
	muls	d6,d4
	add.l	d4,d3
	eor.l	d7,d3
	;
	;if both a1's behind, no swap
	;
	move.l	d2,d4
	and.l	d3,d4
	bmi	.loop2	;both a1's behind...
	;
	;if both a1's in front, swap
	move.l	d2,d4
	or.l	d3,d4
	bpl	.swap
	;
	bra	.loop2
	;
.swap	;a1 is infront of a0! make a1 new frontmost
	bra	.loop
	move.l	a1,a0
	move.l	a3,a2
	bra	.loop2
	;
.none	;OK, none in front of this (a0)
	;
	move.l	(a0),(a2)	;unlink from inlist
	clr.l	(a0)
	move.l	outlistf(pc),a2
	move.l	a0,(a2)
	move.l	a0,outlistf
	bra	.loop0
	;
.done	;move.l	inlist(pc),d0
	;bne	.loop0
	rts

	elseif

	;a1=-(y2-y1):b1=(x2-x1):c1=x1*a1+y1*b1 ;line a/campos
	;a2=-(y4-y3):b2=(x4-x3):c2=x3*a2+y3*b2 ;line b/campos
	;
	;If both B in front of A, yes!
	;
	;If Sgn((x1-x3)*a1+(y1-y3)*b1)=Sgn(c1)
	;  If Sgn((x1-x4)*a1+(y1-y4)*b1)=Sgn(c1)
	;    tr=-1:Return
	;  EndIf
	;EndIf
	;
	;if both A behind B, yes!
	;
	;If Sgn((x3-x1)*a2+(y3-y1)*b2)<>Sgn(c2)
	;  If Sgn((x3-x2)*a2+(y3-y2)*b2)<>Sgn(c2)
	;    tr=-1:Return
	;  EndIf
	;EndIf
	;
	;if both A in front of B, no!
	;
	;If Sgn((x3-x1)*a2+(y3-y1)*b2)=Sgn(c2)
	;  If Sgn((x3-x2)*a2+(y3-y2)*b2)=Sgn(c2)
	;    tr=0:Return
	;  EndIf
	;EndIf
	;
	;if both B behind A, no!
	;
	;If Sgn((x1-x3)*a1+(y1-y3)*b1)<>Sgn(c1)
	;  If Sgn((x1-x4)*a1+(y1-y4)*b1)<>Sgn(c1)
	;    tr=0:Return
	;  EndIf
	;EndIf
	;
	;tr=-1:Return

	elseif

castwalls	;process 'walls' list
	;
	move.l	castrots(pc),a6
	move	minx(pc),d7
	lea	0(a6,d7*8),a6
	move.l	vertdraws(pc),a4
	;
.loop	;do this vert line!
	;
	lea	outlist(pc),a5
	;
.loop2a	move.l	(a5),d0
	beq	.empty
	move.l	d0,a5
	;
	cmp	wl_lsx(a5),d7
	beq	.empty
	blt.s	.loop2a
	cmp	wl_rsx(a5),d7
	beq	.empty
	bgt.s	.loop2a
	;
	movem	wl_lx(a5),d0-d1
	muls	(a6),d0
	muls	2(a6),d1
	add.l	d1,d0	;LX!
	bgt	.loop2a
	;
	movem	wl_rx(a5),d1-d2
	muls	(a6),d1
	muls	2(a6),d2
	add.l	d2,d1	;RX!
	blt	.loop2a
	;
	lsl.l	#exshft,d0
	lsl.l	#exshft,d1
	sub.l	d0,d1
	add.l	#1<<(exshft-1),d1	;+.5
	;
	swap	d1
	tst	d1
	ble.s	.dfix
	neg.l	d0
	divu	d1,d0
	bvc.s	.noov
.dfix	moveq	#-1,d0
.noov	lsr	#1,d0	;fraction -> unsigned
	;
	movem	wl_lx(a5),d1-d2
	muls	4(a6),d1
	muls	6(a6),d2
	add.l	d2,d1
	add.l	d1,d1	;LZ
	;
	movem	wl_rx(a5),d2-d3
	muls	4(a6),d2
	muls	6(a6),d3
	add.l	d3,d2
	add.l	d2,d2	;RZ
	;
	sub.l	d1,d2
	add.l	#$8000,d2	;+.5
	swap	d2
	muls	d0,d2
	add.l	d2,d2
	add.l	d1,d2
	add.l	#$8000,d2
	;
	swap	d2
	tst	d2
	ble	.loop2a
	;
	cmp	#maxz,d2
	bcs	.zisok
	;
.empty	move	#32767,vd_z(a4)
	clr.l	vd_data(a4)
	bra	.next
.zisok	;
	;d0=frac, d2=z, a5=item
	;
	move	d2,d3
	lsr	#darkshft,d3
	movem	d2-d3,vd_z(a4)
	;
	moveq	#-128,d3
	sub	camy(pc),d3
	ext.l	d3
	lsl.l	#focshft,d3
	divs	d2,d3	;top Y
	;
	move	camy(pc),d4
	neg	d4
	ext.l	d4
	lsl.l	#focshft,d4
	divs	d2,d4	;bot Y (0)
	;
	sub	d3,d4
	movem	d3-d4,vd_y(a4)
	;
	lea	textures(pc),a3
	move	wl_t(a5),d1
	move.l	-4(a3,d1*4),a3	;texture!
	;
	;calc ystep...
	movem	te_hand(a3),d1
	addq	#1,d1
	swap	d1
	ext.l	d4
	divu.l	d4,d1
	move.l	d1,vd_ystep(a4)
	;
	;calc column#
	mulu	wl_sc(a5),d0
	;
	move	te_wshift(a3),d1
	addq	#1,d1
	lsl.l	d1,d0
	swap	d0
	move	te_wand(a3),d1
	and	d1,d0
	;
	move	te_hshift(a3),d1
	lsl	d1,d0
	;
	lea	te_size(a3,d0),a3
	move.l	a3,vd_data(a4)
	;
.next	;onto next display column
	;
	lea	vd_size(a4),a4
	addq	#8,a6
	addq	#1,d7
	cmp	maxx(pc),d7
	blt	.loop
	;
	rts

dbwindow	;a0=window to double buffer....
	;
	movem.l	wi_cop(a0),d0-d1
	cmp.l	d0,d1
	bne.s	.skip
	move.l	wi_cop2(a0),d1
.skip	move.l	d1,wi_cop(a0)
	;
usewindow	;a0=window to use...
	;
	move.l	wi_cop(a0),cop
	move.l	wi_bmap(a0),bitmap
	clr.l	cursx
	;
	move	wi_copmod(a0),copmod
	move	wi_w(a0),d0
	move	d0,width
	lsr	#1,d0
	move	d0,maxx
	neg	d0
	move	d0,minx
	move	wi_h(a0),d1
	move	d1,hite
	lsr	#1,d1
	move	d1,maxy
	neg	d1
	move	d1,miny
	;
	rts

renderwindow	;
	;
renderwalls	;
	move.l	vertdraws(pc),a6
	lea	coloffs(pc),a5
	move	width(pc),d7
	subq	#1,d7
	lea	palettes,a2
	;
	move	copmod(pc),d0
	subq	#2,d0
	;
	bwait
	move.l	#$1f00000,$dff040
	move	d0,$dff066
	move.l	#-1,$dff044
	move	#0,$dff074
	;
.loop	move.l	cop(pc),a1
	add.l	(a5)+,a1
	move	hite(pc),d6
	;
	move.l	vd_data(a6),d0
	beq	.vertskip
	;
	move.l	d0,a0
	;
	move	vd_h(a6),d5
	move.l	vd_ystep(a6),d1
	;
	;setup d6, how much more to cls!
	;
	move	vd_y(a6),d0
	add	midy(pc),d0
	bpl.s	.noclip
	;
	;gotta clip Y
	add	d0,d5	;reduce hite
	ble	.vertskip
	neg	d0
	ext.l	d0
	mulu.l	d1,d0	;y step* y
	move.l	d1,d2
	asr.l	#1,d2
	add.l	d2,d0
	cmp	d6,d5
	ble	.skipclip
	move	d6,d5
	bra.s	.skipclip
	;
.noclip	;OK, cls down to Y in d0!
	;
	beq.s	.skcl
	move	d0,d2
	lsl	#6,d2
	or	#1,d2
	bwait
	move.l	a1,$dff054	;Dpth
	move	d2,$dff058	;size...
	;
	;start draw from here...
.skcl	move	d0,d2
	mulu	copmod(pc),d2
	add.l	d2,a1
	;
	move	d0,d2
	add	d5,d2
	sub	d6,d2
	ble.s	.skipclip2
	sub	d2,d5
	ble	.vertskip
	;
.skipclip2	sub	d0,d6
	move.l	d1,d0
	asr.l	#1,d0
.skipclip	;
	sub	d5,d6
	;
	subq	#1,d5
	swap	d0
	swap	d1
	move	vd_pal(a6),d2
	move.l	0(a2,d2*4),a3
	moveq	#0,d2
	moveq	#0,d3
	move	copmod(pc),d4
	ext.l	d4
	;	
.vertloop	;a0=src texture column
	;a1=dest coppoke
	;a3=palette
	;d0=current Y
	;d1=Y step
	;d2=0
	;d3=$00xx
	;d4=copmod
	;d5=count
	;
	move.b	0(a0,d0),d3	;lut entry
	add.l	d1,d0
	addx.l	d2,d0
	move	0(a3,d3*2),(a1) ;colour!
	add.l	d4,a1
	dbf	d5,.vertloop
	;
.vertskip	lsl	#6,d6
	ble.s	.vertskip2
	or	#1,d6
	bwait
	move.l	a1,$dff054
	move	d6,$dff058
	;
.vertskip2	lea	vd_size(a6),a6
	dbf	d7,.loop
	;
	check	.loop
	;
	rts

vwait	move	#1,vbcounter
.loop	tst	vbcounter
	bgt.s	.loop
	rts

;************** DATA ***************************

data

inlist	dc.l	0
inlistf	dc.l	inlist
outlist	dc.l	0
outlistf	dc.l	outlist

dummy	dc.l	0
player1	dc.l	0
player2	dc.l	0
doneflag	dc.l	0
memory	dc.l	0
memat	dc.l	0
shapelist	dc.l	0
bitmap	dc.l	0
palettes	ds.l	16	;16 palettes for 16 brightnesses
rgbs	ds.l	1	;table for calculating palettes

joyx0	dc	0
joyy0	dc	0
joyr0	dc	0
joyb0	dc	0
joyf0	dc	0
joyz0	dc	0
	;
joyx1	dc	0
joyy1	dc	0
joyr1	dc	0
joyb1	dc	0
joyf1	dc	0
joyz1	dc	0

map_map	dc.l	mapinc
map_grid	dc.l	0
map_poly	dc.l	0
map_ppnt	dc.l	0
map_rgbs	dc.l	0
map_txts	dc.l	0
	;
camx	dc	0
camz	dc	0
camy	dc	0
camr	dc	0

	;camera matrix...
cm1	dc	$7ffe
cm2	dc	0
cm3	dc	0
cm4	dc	$7ffe

castrots	dc.l	castrotsinc+8*160	;middle of table
camrots	dc.l	camrotsinc

vertdraws	dc.l	0	;draws for player 1

cop	dc.l	0
copmod	dc	0
width	dc	0
hite	dc	0
minx	dc	0
midx	;
maxx	dc	0
miny	dc	0
midy	;
maxy	dc	0

coplist	dc.l	0
slice1	dc.l	0
slice2	dc.l	0
copstop	dc.l	0

memlist	dc.l	0

dispnest	dc	0

coloffs	ds.l	320	;320 columns max

window1	;
slice	dc.l	slice1
nslice	dc.l	copstop ;slice2	;copstop here for 1 window
	;
	dc	160-45*2
	dc	164-45*2
	dc	90	;max width for 2 high = 90!
	dc	90
	dc	2
	dc	2
	;
	dc	0
	dc.l	0
	dc.l	0
	;
	dc.l	0
	dc.l	0
	dc.l	0
	dc.l	0
	dc	0

window2	;
	dc.l	slice2
	dc.l	copstop
	;
	dc	160-32*2
	dc	164
	dc	64
	dc	59
	dc	2
	dc	2
	;
	dc	0
	dc.l	0
	dc.l	0
	;
	dc.l	0
	dc.l	0
	dc.l	0
	dc.l	0
	dc	0

col0	equ	$123
col1	equ	$fff

copinit	;initialization for display
	;
	dc	$1fc,15
	dc	$096,$0120	;cop/bit/spr DMA off
	;dc	$08e,$2c81,$090,$f4c1
	dc	$092,$38,$094,$a0
	dc	$108,6*40,$10a,6*40
	dc	$100,$7200	;lores, 7 bitplanes
	dc	$102,0
	;
	;lo colour nybs - lo bank
	dc	$106,$0200
	dc	$180,col0,$182,col1
	;
	;lo nybs - hi bank
	dc	$106,$8200
	dc	$180,col0,$182,col1
	;
	;hi colour nybs - lo bank
	dc	$106,0
	dc	$180,col0,$182,col1
	;
	;hi colour nybs - hi bank
	dc	$106,$8000
	dc	$180,col0,$182,col1
	;
	dc	26<<8+1,$fffe
	;
	;slice...
	;
sl1	dc	$e0,0,$e2,0
	dc	$e4,0,$e6,0
	dc	$e8,0,$ea,0
	dc	$ec,0,$ee,0
	dc	$f0,0,$f2,0
	dc	$f4,0,$f6,0
	dc	$f8,0,$fa,0
	dc	$08e,$2c81,$090,$f4c1	;diw
	dc	$096,$8100
	dc	$084,0,$086,0,$08a,0
	;
sl2	dc	$e0,0,$e2,0
	dc	$e4,0,$e6,0
	dc	$e8,0,$ea,0
	dc	$ec,0,$ee,0
	dc	$f0,0,$f2,0
	dc	$f4,0,$f6,0
	dc	$f8,0,$fa,0
	;56
	dc	$08e,$2c81,$090,$f4c1	;diw
	;64
	dc	$096,$8100
	;68
	dc	$084,0,$086,0,$08a,0
	;
cstop	dc	$096,$0100
	dc	$ffff,$fffe
copinitf	;

bigdata

textures	ds.l	48

castrotsinc	incbin	castrots.bin
camrotsinc	incbin	camrots.bin
palette	incbin	texture.pal
font	incbin	font.bin
shrots	dc.l	rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8

;************** SLOW SUBS **********************

slowsubs

rawtable	dc.l	0
ciaaname	dc.b	'ciaa.resource',0
	even

cursx	dc	0
cursy	dc	0

printlong_	movem.l	d0-d7/a0-a6,-(a7)
	move.l	bitmap(pc),a0
	move	cursy(pc),d0
	mulu	#linemod*8,d0
	add.l	d0,a0
	move	cursx(pc),d0
	add	d0,a0
	;
	move.l	64(a7),d0	;num to print
	lea	font,a1
	moveq	#7,d1
	;
.loop	rol.l	#4,d0
	move	d0,d2
	and	#15,d2
	lea	0(a1,d2*8),a2
	move.l	a0,a3
	moveq	#7,d3
	;
.loop2	move.b	(a2)+,(a3)
	lea	linemod(a3),a3
	dbf	d3,.loop2
	;
	addq	#1,a0
	dbf	d1,.loop
	;
	add	#1,cursy
	movem.l	(a7)+,d0-d7/a0-a6
	move.l	(a7)+,(a7)
	rts

loadfile	;a0=name, d1=memtype
	;
	;return d0=pointer
	;
	push
	;
	move.l	d1,-(a7)
	;
	move.l	a0,d1
	move.l	#1005,d2
	move.l	dosbase,a6
	jsr	-30(a6)	;open it!
	move.l	d0,d7	;handle
	beq	.done
	;
	move.l	d7,d1
	moveq	#0,d2
	moveq	#1,d3
	jsr	-66(a6)	;seek to end
	;
	move.l	d7,d1
	moveq	#0,d2
	moveq	#-1,d3	;seek to start
	jsr	-66(a6)
	;
	;d0=length of file ?
	;
	move.l	d0,d3
	move.l	(a7),d1
	jsr	allocmem
	;
	move.l	d0,d2
	move.l	d7,d1
	jsr	-42(a6)
	move.l	d7,d1
	jsr	-36(a6)
	move.l	d2,d0
	;
.done	addq	#4,a7
	pull
	;
	rts

calcpalettes	;a0=palette!
	;
	move.l	map_rgbs(pc),a0
	;
	move.l	rgbs(pc),a1
	move	#255,d0
	move.l	#$f0000,d1
	;
.loop	move	(a0)+,d2
	;
	move	d2,d3
	lsl.l	#8,d2
	and.l	d1,d2
	move.l	d2,(a1)+	;R
	;
	move	d3,d2
	lsl.l	#8,d2
	lsl.l	#4,d2
	and.l	d1,d2
	move.l	d2,(a1)+	;G
	;
	swap	d3
	and.l	d1,d3
	move.l	d3,(a1)+	;B
	;
	dbf	d0,.loop
	;
	lea	palettes(pc),a0
	moveq	#15,d0
	;
.loop2	move.l	rgbs(pc),a1
	move.l	(a0)+,a2
	move	#255,d1
	;
.loop3	movem.l	(a1),d2-d4
	lsr.l	#8,d2
	and	#$f00,d2
	lsr.l	#8,d3
	lsr.l	#4,d3
	and	#$f0,d3
	swap	d4
	and	#$f,d4
	or	d4,d3
	or	d3,d2
	move	d2,(a2)+
	;
	move.l	(a1),d2
	sub.l	#$10000,d2
	bpl.s	.rok
	moveq	#0,d2
.rok	move.l	d2,(a1)+
	;
	move.l	(a1),d3
	sub.l	#$10000,d3
	bpl.s	.gok
	moveq	#0,d3
.gok	move.l	d3,(a1)+
	;
	move.l	(a1),d4
	sub.l	#$10000,d4
	bpl.s	.bok
	moveq	#0,d4
.bok	move.l	d4,(a1)+
	;	
	dbf	d1,.loop3
	dbf	d0,.loop2
	rts

dispoff	tst	dispnest
	bne.s	.skip
	bsr	vwait
	move	#$01a0,$dff096
.skip	addq	#1,dispnest
	rts

dispon	subq	#1,dispnest
	bgt.s	.skip
	bsr	vwait
	move	#$8180,$dff096
.skip	rts

forbid	push
	move.l	4.w,a6
	jsr	-132(a6)
	pull
	rts

permit	push
	move.l	4.w,a6
	jsr	-138(a6)
	pull
	rts

initvbint	push
	move.l	4.w,a6
	moveq	#5,d0
	lea	vbintserver,a1
	jsr	-168(a6)	;addintserver
	pull
	rts

vbcounter	dc	0
framecnt	dc	0

frame	dc	0,0

vbintserver	dc.l	0,0
	dc.b	2,0
	dc.l	0
vbintdata	dc.l	vbcounter
vbintcode	dc.l	vbhandler

finitvbint	push
	move.l	4.w,a6
	moveq	#5,d0
	lea	vbintserver,a1
	jsr	-174(a6)
	pull
	rts

ownblitter	push
	move.l	grbase,a6
	jsr	-456(a6)
	btst	#6,$dff002
.bwait	btst	#6,$dff002
	bne.s	.bwait
	pull
	rts

disownblitter	push
	btst	#6,$dff002
.bwait	btst	#6,$dff002
	bne.s	.bwait
	move.l	grbase,a6
	jsr	-462(a6)
	pull
	rts

makecoloffs	push
	lea	coloffs,a0
	moveq	#2,d0
	moveq	#3,d2
.loop	addq.l	#4,d0
	moveq	#31,d1
.loop2	move.l	d0,(a0)+
	addq.l	#4,d0
	dbf	d1,.loop2
	dbf	d2,.loop
	pull
	rts

grname	dc.b	'graphics.library',0
	even
grbase	dc.l	0
oldview	dc.l	0
dosname	dc.b	'dos.library',0
	even
dosbase	dc.l	0

showwindow	;a0=window
	;
	push
	;
	;poke bitmaps...
	move.l	wi_slice(a0),a1
	move.l	(a1),a1
	move.l	wi_bmap(a0),d0
	moveq	#6,d1	;7 bitplanes
.loop	move	d0,6(a1)
	swap	d0
	move	d0,2(a1)
	swap	d0
	add.l	#40,d0
	addq	#8,a1
	dbf	d1,.loop
	;
	;create DIW
	move.l	wi_slice(a0),a1
	move.l	(a1),a1
	move	wi_y(a0),d0
	move	d0,d1
	add	wi_bh(a0),d1
	lsl	#8,d0
	or	#$81,d0
	move	d0,56+2(a1)
	lsl	#8,d1
	or	#$c1,d1
	move	d1,56+6(a1)
	;
	;create link to next!
	move.l	wi_nslice(a0),a1
	move.l	(a1),d0
	move.l	wi_cop1(a0),a1
	add.l	wi_copmem(a0),a1
	move.l	wi_cop2(a0),a2
	add.l	wi_copmem(a0),a2
	move	d0,-6(a1)
	move	d0,-6(a2)
	swap	d0
	move	d0,-10(a1)
	move	d0,-10(a2)
	;
	pull
	;
showwindowq	;display coplist
	;
	move.l	wi_slice(a0),a1
	move.l	(a1),a1
	move.l	wi_cop(a0),d0
	move	d0,68+6(a1)
	swap	d0
	move	d0,68+2(a1)
	rts

finitdisplay	push
	;
	move.l	grbase,a6
	move.l	oldview,a1
	jsr	-222(a6)	;load view
	jsr	-270(a6)
	jsr	-270(a6)
	move.l	38(a6),$dff080
	move	#0,$dff088
	move	#$81a0,$dff096
	;
	pull
	rts

initdisplay	push
	;
	lea	grname,a1
	move.l	4.w,a6
	jsr	-408(a6)
	move.l	d0,grbase
	;
	move.l	d0,a6
	move.l	34(a6),oldview
	sub.l	a1,a1
	jsr	-222(a6)	;loadview
	;
	move.l	#copinitf-copinit,d0
	moveq	#2,d1
	bsr	allocmem
	move.l	d0,coplist
	;
	move.l	d0,a1
	lea	copinit,a0
	lea	copinitf,a2
	;
.loop	cmp.l	a2,a0
	bcc.s	.done
	move.l	(a0)+,(a1)+
	bra.s	.loop
.done	;
	add.l	#sl1-copinit,d0
	move.l	d0,slice1
	add.l	#sl2-sl1,d0
	move.l	d0,slice2
	add.l	#cstop-sl2,d0
	move.l	d0,copstop
	;
	move.l	copstop,d0
	move.l	slice1,a0
	move.l	slice2,a1
	move	d0,68+6(a0)
	move	d0,68+6(a1)
	swap	d0
	move	d0,68+2(a0)
	move	d0,68+2(a1)
	;
	jsr	-270(a6)
	jsr	-270(a6)
	move.l	coplist,$dff080
	move	#0,$dff088
	;
	pull
	rts

makewindow	;
	;a0=window struct!
	;
	push
	;
	move.l	a0,a2
	;
	move	wi_h(a2),d0
	mulu	wi_ph(a2),d0
	move	d0,wi_bh(a2)
	mulu	#40*7,d0
	;
	move.l	#$10002,d1
	move.l	d0,wi_bmapmem(a2)
	bsr	allocmem
	move.l	d0,wi_bmap(a2)
	;
	;OK, plot colours on bitmap!
	move.l	d0,a0
	move	wi_x(a2),d0
	move	d0,d1
	lsr	#3,d0
	not	d1
	and	#7,d1
	moveq	#127,d7	;colour
	move	wi_w(a2),d6	;width
	subq	#1,d6
	;
.wloop	move	wi_pw(a2),d5
	subq	#1,d5
	;
.wloop2	move	d7,d4
	moveq	#6,d3
	;
.dloop	bclr	d1,0(a0,d0)
	lsr	#1,d4
	bcc.s	.dskip
	bset	d1,0(a0,d0)
.dskip	lea	40(a0),a0
	dbf	d3,.dloop
	;
	lea	-40*7(a0),a0
	subq	#1,d1
	bpl.s	.dskip2
	moveq	#7,d1
	addq	#1,d0
.dskip2	dbf	d5,.wloop2
	;
	subq	#1,d7
	dbf	d6,.wloop
	;
	move.l	wi_bmapmem(a2),d0
	sub.l	#40*7,d0
	lsr.l	#2,d0
	subq	#1,d0
	lea	40*7(a0),a1
.cbloop	move.l	(a0)+,(a1)+
	dbf	d0,.cbloop
	;
	;how many copins on one line?
	move	wi_w(a2),d0
	move	d0,d1
	subq	#1,d0
	lsr	#5,d0	;how many bank changes per line!
	addq	#4,d0	;2 waits - 1 eor, 1 init bank select
	add	d1,d0	;+colpokes
	;
	move	d0,d1
	lsl	#2,d1
	move	d1,wi_copmod(a2)
	;
	mulu	wi_h(a2),d0
	addq	#5,d0	;2 waits and cop jump at end
	;
	lsl.l	#2,d0	;4 bytes/copins
	moveq	#2,d1	;cop in chip
	move.l	d0,wi_copmem(a2)
	lsl.l	#1,d0	;2 coplists!
	bsr	allocmem
	move.l	d0,wi_cop(a2)
	move.l	d0,wi_cop1(a2)
	;
	move.l	d0,a0
	move	wi_y(a2),d6
	move	wi_h(a2),d7
	subq	#1,d7
	move	#$111,d3	;test colour
	move	#$8000,d4	;Colour Eor
	;
.hloop	;make one copline...
	;
	moveq	#127,d0	;colour reg to poke
	move	wi_w(a2),d1
	subq	#1,d1
	;
.lloop	move	d0,d2
	addq	#1,d2
	and	#31,d2
	bne.s	.notnbank
	;
	;new bank....
	move	d0,d2
	sub	#31,d2
	and	#$ffe0,d2
	lsl	#8,d2
	or	d4,d2	;eor bank
	move	#$106,(a0)+	;bank select
	move	d2,(a0)+
	;
.notnbank	move	d0,d2
	and	#31,d2
	add	d2,d2
	add	#$180,d2
	move	d2,(a0)+	;colour poke
	move	d3,(a0)+
	add	#$111,d3
	subq	#1,d0
	dbf	d1,.lloop
	;
	bsr	.makewait
	;
	;ok, now do EOR!
	move	#$10c,(a0)+
	;move	#0,d4
	move	d4,(a0)+
	bchg	#15,d4
	;
	dbf	d7,.hloop
	;
	bsr	.makewait
	;
	move.l	#$00840000,(a0)+
	move.l	#$00860000,(a0)+
	move.l	#$008a0000,(a0)+
	;
	;OK, 1 list created...copy to other!
	;
	move.l	wi_cop1(a2),a0
	move.l	a0,a1
	add.l	wi_copmem(a2),a1
	move.l	a1,wi_cop2(a2)
	move.l	a1,a3
	;
.copycop	move.l	(a0)+,(a3)+
	cmp.l	a1,a0
	bcs.s	.copycop
	;
	pull
	rts

.makewait	;
	;make wait ins.
	move.l	#$01fe0000,(a0)+ ;no wait - nop
	cmp	#256,d6
	blt.s	.not256
	move.l	#$00e1fffe,-4(a0)
	sub	#256,d6
.not256	move.b	d6,(a0)+
	move.b	#1,(a0)+
	move	#$fffe,(a0)+	;wait!
	add	wi_ph(a2),d6
	rts

allocmem	;
	;d0=size, d1=requirements
	;
	push
	move.l	4.w,a6
	;
	addq.l	#8,d0
	move.l	d0,-(a7)
	jsr	-198(a6)
	move.l	d0,a0
	move.l	memlist,(a0)
	move.l	(a7)+,4(a0)
	move.l	a0,memlist
	addq.l	#8,a0
	move.l	a0,d0
	;
	pull
	rts

freememlist	push
	move.l	4.w,a6
	;
.more	move.l	memlist,d0
	beq.s	.done
	move.l	d0,a1
	move.l	(a1),memlist
	move.l	4(a1),d0
	jsr	-210(a6)
	bra.s	.more
	;
.done	pull
	rts

freemem	;
	;a1=address to free!
	;
	push
	move.l	4.w,a6
	subq.l	#8,a1
	move.l	#memlist,d0
	;
.more	move.l	d0,a0
	move.l	(a0),d0
	beq.s	.done	;not found!
	cmp.l	d0,a1
	bne.s	.more
	;
	move.l	(a1),(a0)
	move.l	4(a1),d0
	jsr	-210(a6)
	;
.done	pull
	rts

initmap	push
	;
	move.l	map_map,a0
	;
	move.l	a0,a1
	add.l	(a0),a1
	move.l	a1,map_grid
	;
	move.l	a0,a1
	add.l	4(a0),a1
	move.l	a1,map_poly
	;
	move.l	a0,a1
	add.l	8(a0),a1
	move.l	a1,map_ppnt
	;
	move.l	a0,a1
	add.l	12(a0),a1
	move.l	a1,map_rgbs
	;
	move.l	a0,a1
	add.l	16(a0),a1
	move.l	a1,map_txts
	;
	jsr	calcpalettes
	jsr	loadtxts
	;
	pull
	rts

loadtxts	move.l	map_txts,a5	;texture names
	lea	textures,a6
	moveq	#47,d7
.ltl	lea	.temp(pc),a0
.ltl2	move.b	(a5)+,(a0)+
	bne.s	.ltl2
	cmp.l	#.temp+1,a0
	beq.s	.notext
	lea	.temp2(pc),a0
	moveq	#1,d1
	jsr	loadfile
.notext	move.l	d0,(a6)+
	dbf	d7,.ltl
	rts

.temp2	dc.b	'txts/'
.temp	ds.b	64
	cnop	0,4
	
mapinc	incbin	temp_map

man	incbin	ggfx/man1.chk
rot1	incbin	rot1.chk
rot2	incbin	rot2.chk
rot3	incbin	rot3.chk
rot4	incbin	rot4.chk
rot5	incbin	rot5.chk
rot6	incbin	rot6.chk
rot7	incbin	rot7.chk
rot8	incbin	rot8.chk
blob	incbin	ggfx/blob.chk
blob2	incbin	ggfx/blob2.chk

	cnop	0,4

objinfo
player1_	dc.l	player1
.ob_rotspeed	dc.l	$40000
.ob_movspeed	dc.l	$a0000
.ob_shape	dc.l	man
.ob_logic	dc.l	playerlogic
.ob_render	dc.l	drawshape
.ob_die	dc.l	playerdie
.ob_eyey	dc	-64	;eye height
.ob_firey	dc	-48	;where bullets come from
.ob_colltype	dc	0
.ob_collwith	dc	1
.ob_cntrl	dc	1	;for player 0,1=joyport
.ob_rndfire	dc	0
.ob_damage	dc	0
.ob_hitpoints	dc	5
.ob_rndturn	dc	0
.ob_think	dc	0
objinfof

player2_	dc.l	player2
.ob_rotspeed	dc.l	$30000
.ob_movspeed	dc.l	$a0000
.ob_shape	dc.l	man
.ob_logic	dc.l	playerlogic
.ob_render	dc.l	drawshape
.ob_die	dc.l	playerdie
.ob_eyey	dc	-64	;eye height
.ob_firey	dc	-48	;where bullets come from
.ob_colltype	dc	0
.ob_collwith	dc	1
.ob_cntrl	dc	0	;for player 0,1=joyport
.ob_rndfire	dc	0	;guess what!
.ob_damage	dc	0
.ob_hitpoints	dc	5
.ob_rndturn	dc	0
.ob_think	dc	0

monster1_	dc.l	dummy
.ob_rotspeed	dc.l	$30000
.ob_movspeed	dc.l	$60000
.ob_shape	dc.l	rot1
.ob_logic	dc.l	monsterlogic
.ob_render	dc.l	drawshape_8
.ob_die	dc.l	killobject
.ob_eyey	dc	-64	;eye height
.ob_firey	dc	-48	;where bullets come from
.ob_colltype	dc	0
.ob_collwith	dc	3
.ob_cntrl	dc	0	;for player 0,1=joyport
.ob_rndfire	dc	0	;guess what!
.ob_damage	dc	0
.ob_hitpoints	dc	1
.ob_rndturn	dc	$400
.ob_think	dc	0
